<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elliptic Curve</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: auto;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            min-height: 100dvh;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
        }

        .container {
            width: 100%;
            margin: 0;
            min-height: 100vh;
            background: #000;
            border-radius: 0;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow-x: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 20px;
        }

        .panel {
            background: #111;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .panel h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #ddd;
            font-weight: 600;
            font-size: 1.1em;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #444;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
            background: #111;
            color: #e6e6e6;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .inline-inputs {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
            margin-top: 10px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .result-box {
            background: #000;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
            color: #e6e6e6;
        }

        .result-box h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .point-item {
            background: #161616;
            padding: 10px;
            margin: 8px 0;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            border-left: 4px solid #667eea;
            color: #e6e6e6;
        }

        .point-at-infinity {
            color: #764ba2;
            font-weight: bold;
        }

        .curve-info {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.12) 0%, rgba(118, 75, 162, 0.12) 100%);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
            color: #e6e6e6;
        }

        .curve-info code {
            background: #000;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 1.1em;
            color: #667eea;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .operation-result {
            background: rgba(102, 126, 234, 0.12);
            border: 2px solid #667eea;
            padding: 20px;
            border-radius: 10px;
            margin-top: 15px;
            font-size: 1.1em;
            color: #dfe6ff;
        }

        .operation-result strong {
            color: #667eea;
        }

        .error {
            background: rgba(244, 67, 54, 0.12);
            border: 2px solid #f44336;
            color: #ff8a80;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        canvas {
            border: 2px solid #444;
            border-radius: 10px;
            background: #000;
            width: 100%;
            max-width: none;
            height: 60vh;
            max-height: none;
            display: block;
            margin: 10px auto;
        }

        .info-badge {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            margin-left: 10px;
        }

        .point-info {
            margin-top: 6px;
            color: #ccc;
            font-size: 0.95em;
            min-height: 1.2em;
        }

        /* removed badge styling */

        @media (max-width: 1024px) {
            .content {
                grid-template-columns: 1fr;
            }
            .tab-pane.active {
                grid-template-columns: 1fr;
            }
        }

        .math-formula {
            background: #000;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: center;
            font-size: 1.3em;
            font-style: italic;
            color: #ddd;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .tabs .tab-btn {
            width: auto;
            padding: 12px 18px;
            font-size: 1.05em;
        }
        .tabs .tab-btn.active {
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.4);
            transform: translateY(-1px);
        }
        .tab-pane {
            display: none;
            grid-column: 1 / -1;
        }
        .tab-pane.active {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        /* About tab */
        #aboutTab .panel.full-width {
            max-width: 1000px;
            margin: 0 auto;
        }
        #aboutTab .panel { text-align: center; }
        #aboutTab h2 { font-size: 2.4em; }
        #aboutTab p { font-size: 1.3em; line-height: 1.9; color: #ccc; }
        #aboutTab ul {
            display: inline-block;
            text-align: left;
            margin: 10px auto;
            font-size: 1.2em;
            color: #ccc;
        }
        #aboutTab li { margin: 8px 0; }

        /* Animation controls */
        .anim-controls {
            display: grid;
            grid-template-columns: auto auto 1fr auto auto;
            align-items: center;
            gap: 10px;
            max-width: 600px;
            margin: 10px auto 0 auto;
        }
        .anim-controls button {
            width: auto;
            padding: 8px 14px;
            margin-top: 0;
        }
        .anim-controls input[type="range"] {
            width: 100%;
            background: #222;
            height: 6px;
            border-radius: 3px;
            outline: none;
        }
        .anim-controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        .anim-controls input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        .anim-controls .step-label {
            color: #ddd;
            font-weight: 600;
            min-width: 60px;
            text-align: right;
        }

        /* Tabs + Profile */
        .tabs-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative;
        }
        .tabs-bar .tabs { flex: 1; }
        .profile-area {
            margin-left: auto;
            position: relative;
        }
        .profile-btn {
            background: transparent;
            color: #fff;
            border: 2px solid #667eea;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        .profile-menu {
            position: absolute;
            right: 0;
            top: 48px;
            background: #111;
            border: 1px solid #333;
            border-radius: 8px;
            min-width: 200px;
            box-shadow: 0 10px 24px rgba(0,0,0,0.4);
            display: none;
            z-index: 10;
            opacity: 0;
            transform: translateY(-6px);
            transition: opacity 180ms ease, transform 180ms ease;
        }
        .profile-menu.visible { display: block; opacity: 1; transform: translateY(0); }
        .profile-menu .header {
            padding: 10px 12px;
            color: #aaa;
            border-bottom: 1px solid #222;
            font-size: 0.95em;
        }
        .profile-menu .dropdown-item {
            display: block;
            width: 100%;
            padding: 10px 12px;
            background: transparent;
            color: #e6e6e6;
            border: none;
            text-align: left;
            cursor: pointer;
        }
        .profile-menu .dropdown-item:hover {
            background: rgba(102, 126, 234, 0.12);
        }

        /* Auth full-screen card */
        .auth-overlay {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex; /* keep present for transitions */
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 260ms ease;
        }
        .auth-overlay.visible { opacity: 1; pointer-events: auto; }
        .auth-card {
            background: #fff;
            color: #111;
            border-radius: 18px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            width: 100%;
            max-width: 460px; /* match signup card width */
            padding: 24px;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 260ms ease, transform 260ms ease;
        }
        .auth-overlay.visible .auth-card { opacity: 1; transform: translateY(0); }
        .auth-form { width: 100%; max-width: 360px; margin: 0 auto; }
        .auth-icon {
            width: 52px;
            height: 52px;
            border-radius: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 24px;
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
        }
        .auth-title { font-size: 1.25rem; font-weight: 700; margin-top: 10px; }
        .auth-sub { color: #666; font-size: 0.95rem; margin-top: 4px; }
        .auth-field { position: relative; margin-top: 14px; }
        .auth-field input {
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 12px;
            padding: 12px 16px 12px 42px;
            font-size: 0.95rem;
            outline: none;
        }
        .auth-field input:focus { border-color: #667eea; box-shadow: 0 0 0 3px rgba(102,126,234,0.15); }
        .auth-ico {
            position: absolute; left: 12px; top: 50%; transform: translateY(-50%);
            width: 18px; height: 18px; fill: #667eea; opacity: 0.9;
        }
        .auth-right-link { font-size: 0.9rem; color: #667eea; text-decoration: none; }
        .auth-right-row { display: flex; justify-content: flex-end; margin-top: 6px; }
        .btn-primary-dark {
            width: 100%;
            padding: 14px 18px;
            border-radius: 999px;
            background: #000;
            color: #fff;
            border: none;
            font-weight: 700;
            cursor: pointer;
            margin-top: 14px;
        }
        .auth-sep { display: flex; align-items: center; gap: 10px; margin: 14px 0; }
        .auth-sep .line { flex: 1; height: 1px; background: #eee; }
        .auth-sep .txt { color: #999; font-size: 0.85rem; }
        .btn-row { display: grid; grid-template-columns: 1fr; gap: 10px; }
        @media (min-width: 420px) { .btn-row { grid-template-columns: 1fr 1fr; } }
        .btn-pill { padding: 10px 16px; border-radius: 999px; border: 1px solid #ddd; background: #fff; color: #111; cursor: pointer; }
        .btn-pill.secondary { border-color: #667eea; color: #667eea; }
        .btn-pill.ghost { border-color: #ccc; color: #333; }
        .auth-msg { color: #e53935; min-height: 1.2em; margin-top: 6px; font-size: 0.9rem; }

        /* Auth panel */
        .auth-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            align-items: start;
        }
        .auth-status {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 0 0 0;
            color: #ddd;
        }
        .auth-actions {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        @media (max-width: 1024px) {
            .auth-grid { grid-template-columns: 1fr; }
        }
    </style>
    <style>
        /* Subtabs */
        .subtabs {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 8px 0 14px 0;
        }
        .subtabs .subtab-btn {
            width: auto;
            padding: 10px 16px;
            font-size: 1.0em;
        }
        .subtabs .subtab-btn.active {
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.4);
            transform: translateY(-1px);
        }
        .subtab-pane { display: none; grid-column: 1 / -1; }
        .subtab-pane.active { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; }
        @media (max-width: 1024px) { .subtab-pane.active { grid-template-columns: 1fr; } }

        /* Real range inline formatter */
        .range-inline { display:flex; align-items:center; gap:8px; color:#ddd; margin-top:4px; flex-wrap: nowrap; white-space: nowrap; }
        .range-inline .token { color:#aaa; font-family: 'Courier New', monospace; }
        .range-input { width: 8ch; max-width: 8ch; text-align: center; }
        @media (max-width: 480px) { .range-input { width: 8ch; max-width: 8ch; } }

        /* History list */
        .history-controls { display:flex; gap:10px; margin-bottom: 10px; }
        .history-list { max-height: 500px; overflow-y: auto; }
        .history-item {
            background: #161616;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .history-item:hover { background: #1a1a1a; border-color: #667eea; transform: translateX(5px); }
        .history-item .operation-icon { font-size: 24px; margin-right: 15px; }
        .history-item .operation-details { flex: 1; color: #ddd; }
        .history-item .operation-type { color: #667eea; font-weight: bold; margin-bottom: 5px; }
        .history-item .operation-params { font-family: 'Courier New', monospace; color: #999; font-size: 0.9em; }
        .history-item .timestamp { color: #666; font-size: 0.85em; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Elliptic Curve</h1>
        </div>

        <!-- Auth Overlay -->
        <div id="authOverlay" class="auth-overlay">
            <div class="auth-card">
                <div style="text-align:center;">
                    <div class="auth-icon" aria-hidden="true">üîê</div>
                    <div class="auth-title">Sign in</div>
                    <div class="auth-sub">Access your elliptic curve workspace.</div>
                </div>
                <div class="auth-form">
                    <div class="auth-field">
                        <svg class="auth-ico" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 12c2.7 0 5-2.3 5-5s-2.3-5-5-5-5 2.3-5 5 2.3 5 5 5zm0 2c-3.3 0-10 1.7-10 5v3h20v-3c0-3.3-6.7-5-10-5z"/></svg>
                        <input id="loginUsername" type="text" placeholder="Username">
                        <div id="loginUsernameErr" class="field-error" style="display:none;"></div>
                    </div>
                    <div class="auth-field">
                        <svg class="auth-ico" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 17a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm6-6V9a6 6 0 1 0-12 0v2H4v10h16V11h-2zm-8-2a4 4 0 1 1 8 0v2H10V9z"/></svg>
                        <input id="loginPassword" type="password" placeholder="Password">
                        <div id="loginPasswordErr" class="field-error" style="display:none;"></div>
                    </div>
                    <div class="auth-right-row">
                        <a class="auth-right-link" href="#" onclick="alert('Reset link flow not implemented')">Forgot password?</a>
                    </div>
                    <button class="btn-primary-dark" onclick="submitLoginCard()">Get Started</button>
                    <div class="auth-sep"><div class="line"></div><div class="txt">Or</div><div class="line"></div></div>
                    <div class="btn-row">
                        <button class="btn-pill secondary" onclick="openSignupPage()">Create an account</button>
                        <button class="btn-pill ghost" onclick="continueAsGuestCard()">Continue as guest</button>
                    </div>
                    <div id="authMsgOverlay" class="auth-msg" aria-live="polite"></div>
                </div>
            </div>
        </div>
        <script>
            // Ensure overlay is shown immediately if forced, before any other JS runs
            (function(){
                try {
                    var force = (localStorage.getItem('force_login') === '1') || (new URLSearchParams(location.search).get('login') === '1');
                    if (force) {
                        var ov = document.getElementById('authOverlay');
                        if (ov) ov.classList.add('visible');
                    }
                } catch(_) {}
            })();
        </script>

        <div class="content">
            
            <!-- Tabs Header + Profile -->
            <div class="panel full-width">
                <div class="tabs-bar">
                    <div class="tabs">
                        <button class="tab-btn" data-tab="aboutTab" onclick="switchTab('aboutTab')">About</button>
                        <button class="tab-btn" data-tab="realTab" onclick="switchTab('realTab')">Curve over ‚Ñù</button>
                        <button class="tab-btn active" data-tab="fpTab" onclick="switchTab('fpTab')">Curve over Fp</button>
                    </div>
                    <div class="profile-area">
                        <button id="profileBtn" class="profile-btn" onclick="toggleProfileMenu()" aria-haspopup="true" aria-expanded="false" title="Profile">üë§</button>
                        <div id="profileMenu" class="profile-menu" role="menu">
                            <div class="header">Signed in as <span id="profileName">user</span></div>
                            <button id="menuLogin" class="dropdown-item" style="display:none;" onclick="hideProfileMenu(); openLoginModal();">Login</button>
                            <button id="menuLogout" class="dropdown-item" onclick="hideProfileMenu(); doLogout();">Logout</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- About Tab -->
            <div id="aboutTab" class="tab-pane">
                <div class="panel full-width">
                    <h2>About</h2>
                    <p style="margin-bottom: 12px; color:#ccc;">
                        This app lets you explore elliptic curves over finite fields. You can generate all points on a curve,
                        add two points using the group law, and follow scalar multiplication step by step with a clear, discrete visualization.
                    </p>

                    <div class="math-formula">y¬≤ = x¬≥ + ax + b (mod p)</div>

                    <p style="margin: 12px 0; color:#ccc;">
                        Here, <strong>p</strong> is a prime modulus, and <strong>a</strong>, <strong>b</strong> are integers. All arithmetic (additions,
                        subtractions, multiplications, divisions) is performed modulo <strong>p</strong>. The set of points that satisfy the equation,
                        plus a special identity element <strong>O</strong> (the ‚Äúpoint at infinity‚Äù), forms an abelian group under a well‚Äëdefined addition rule.
                    </p>

                    <h3 style="color:#e6e6e6; margin-top:16px;">Key Concepts</h3>
                    <ul style="margin-left: 20px; line-height: 1.8; color:#ccc;">
                        <li><strong>Valid curve:</strong> The discriminant <code>Œî = 4a¬≥ + 27b¬≤ (mod p)</code> must be non‚Äëzero to avoid singularities.</li>
                        <li><strong>Point at infinity (O):</strong> Acts as the identity element: <code>P + O = P</code>.</li>
                        <li><strong>Negation:</strong> For a point <code>P = (x, y)</code>, its inverse is <code>-P = (x, -y mod p)</code>.</li>
                        <li><strong>Point addition:</strong> The line through <code>P</code> and <code>Q</code> intersects the curve at a third point; reflect it across the x‚Äëaxis to get <code>P + Q</code>. In finite fields, the ‚Äúline‚Äù is an algebraic relation handled with modular arithmetic.</li>
                        <li><strong>Point doubling:</strong> When <code>P = Q</code>, use the tangent at <code>P</code> to compute <code>2P</code>.</li>
                        <li><strong>Scalar multiplication:</strong> Repeated addition, efficiently computed via the double‚Äëand‚Äëadd method.</li>
                    </ul>

                    <h3 style="color:#e6e6e6; margin-top:16px;">How to Use This App</h3>
                    <ul style="margin-left: 20px; line-height: 1.8; color:#ccc;">
                        <li><strong>Initialization:</strong> Pick <code>a</code>, <code>b</code>, and a prime <code>p</code>, then click ‚ÄúFind All Points on Curve‚Äù. The list below shows every point (including <code>O</code>).</li>
                        <li><strong>Visualization:</strong> The canvases plot all points with axes from <code>0</code> to <code>p‚àí1</code> on both x and y. Use the ‚ÄúShow point labels‚Äù toggle to annotate points.</li>
                        <li><strong>Point Addition:</strong> Choose <code>P</code> and <code>Q</code> to compute <code>P + Q</code>. The result is highlighted on the plot.</li>
                        <li><strong>Scalar Multiplication:</strong> Choose a point <code>P</code> and scalar <code>k</code>. Step through each intermediate multiple with the controls and slider.</li>
                    </ul>

                    <h3 style="color:#e6e6e6; margin-top:16px;">Tips and Notes</h3>
                    <ul style="margin-left: 20px; line-height: 1.8; color:#ccc;">
                        <li>Choose moderate primes (for example, <code>p ‚âà 50‚Äì200</code>) to keep the plots readable while still showing structure.</li>
                        <li>If <code>Œî = 0</code> for your parameters, pick a different <code>a</code> and <code>b</code> so the curve is non‚Äësingular.</li>
                        <li>The ‚ÄúShow point labels‚Äù option is off by default to reduce clutter. Turn it on when you need exact coordinates.</li>
                        <li>All points are plotted in a grid of integers; there are no fractional coordinates in this finite‚Äëfield setting.</li>
                    </ul>

                    <h3 style="color:#e6e6e6; margin-top:16px;">Why Elliptic Curves?</h3>
                    <p style="margin: 8px 0; color:#ccc;">
                        Elliptic‚Äëcurve groups enable compact, efficient public‚Äëkey operations such as key exchange and digital signatures.
                        Over finite fields, their algebraic structure provides strong security per bit of key size and underpins many modern protocols.
                    </p>
                </div>
            </div>

            <!-- Real Curve (‚Ñù) Tab -->
            <div id="realTab" class="tab-pane">
                <div class="panel full-width">
                    <h2>Curve over ‚Ñù</h2>
                    <div class="math-formula">y¬≤ = x¬≥ + ax + b</div>
                    <div class="subtabs">
                        <button class="subtab-btn active" data-subtab="realInitPane" onclick="switchSubtab('real','realInitPane')">Initialization</button>
                        <button class="subtab-btn" data-subtab="realAddPane" onclick="switchSubtab('real','realAddPane')">Point Addition</button>
                        <button class="subtab-btn" data-subtab="realMulPane" onclick="switchSubtab('real','realMulPane')">Scalar Multiplication</button>
                        <button class="subtab-btn" data-subtab="realHistoryPane" onclick="switchSubtab('real','realHistoryPane'); loadHistory('real');">History</button>
                    </div>
                </div>

                <div id="realInitPane" class="subtab-pane active">
                    <div class="panel">
                        <h2>Define Curve</h2>
                        <div class="form-group">
                            <div class="inline-inputs">
                                <div>
                                    <label for="realParamA">a</label>
                                    <input type="number" step="any" id="realParamA" value="-1" placeholder="a">
                                </div>
                                <div>
                                    <label for="realParamB">b</label>
                                    <input type="number" step="any" id="realParamB" value="1" placeholder="b">
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <div class="inline-inputs">
                                <div>
                                    <label for="realRangeMin">Range (x,y)</label>
                                    <div class="range-inline" aria-label="Real curve axis range">
                                        <span class="token">x,y ‚àà [</span>
                                        <input class="range-input" type="number" step="any" id="realRangeMin" value="-10" placeholder="min">
                                        <span class="token">,</span>
                                        <input class="range-input" type="number" step="any" id="realRangeMax" value="10" placeholder="max">
                                        <span class="token">]</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button onclick="initRealCurve()">Initialize Curve</button>
                    </div>
                    <div class="panel">
                        <h2>Visualization</h2>
                        <p style="margin-bottom: 15px; color: #888;">Smooth curve plot over real numbers</p>
                        <canvas id="realCurveCanvas" width="600" height="500"></canvas>
                        <label style="display:block; margin-top:8px; color:#aaa; font-size:0.95em;">
                            <input id="realShowLabels" type="checkbox" onchange="redrawRealCanvases()"> Show point labels
                        </label>
                    </div>
                </div>

                <div id="realAddPane" class="subtab-pane">
                    <div class="panel">
                        <h2>Point Addition (‚Ñù)</h2>
                        <p style="margin-bottom: 15px; color: #888;">Geometric chord/tangent visualization</p>
                        <div class="form-group">
                            <div class="inline-inputs">
                                <div>
                                    <label for="realP1X">P.x</label>
                                    <input type="number" step="any" id="realP1X" placeholder="x‚ÇÅ">
                                </div>
                                <div>
                                    <label for="realP1Y">P.y</label>
                                    <input type="number" step="any" id="realP1Y" placeholder="y‚ÇÅ">
                                </div>
                                <div>
                                    <label for="realSelectMode">Pick Mode</label>
                                    <select id="realSelectMode">
                                        <option value="P">Select P</option>
                                        <option value="Q">Select Q</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <div class="inline-inputs">
                                <div>
                                    <label for="realP2X">Q.x</label>
                                    <input type="number" step="any" id="realP2X" placeholder="x‚ÇÇ">
                                </div>
                                <div>
                                    <label for="realP2Y">Q.y</label>
                                    <input type="number" step="any" id="realP2Y" placeholder="y‚ÇÇ">
                                </div>
                                <div>
                                    <label>&nbsp;</label>
                                    <button onclick="addPointsReal()">Calculate P + Q</button>
                                </div>
                            </div>
                        </div>
                        <div id="realAdditionResult"></div>
                    </div>
                    <div class="panel">
                        <h2>Visualization</h2>
                        <p style="margin-bottom: 15px; color: #888;">Click on the curve to set P or Q</p>
                        <canvas id="realAdditionCanvas" width="600" height="500"></canvas>
                        <label style="display:block; margin-top:8px; color:#aaa; font-size:0.95em;">
                            <input id="realAdditionShowLabels" type="checkbox" onchange="drawRealAdditionScene()"> Show point labels
                        </label>
                    </div>
                </div>

                <div id="realMulPane" class="subtab-pane">
                    <div class="panel">
                        <h2>Scalar Multiplication (‚Ñù)</h2>
                        <p style="margin-bottom: 15px; color: #888;">Follow k √ó P along the curve</p>
                        <div class="form-group">
                            <div class="inline-inputs">
                                <div>
                                    <label for="realK">k</label>
                                    <input type="number" id="realK" value="3" placeholder="k">
                                </div>
                                <div>
                                    <label for="realMulPX">P.x</label>
                                    <input type="number" step="any" id="realMulPX" placeholder="x">
                                </div>
                                <div>
                                    <label for="realMulPY">P.y</label>
                                    <input type="number" step="any" id="realMulPY" placeholder="y">
                                </div>
                            </div>
                        </div>
                        <button onclick="scalarMultiplyReal()">Calculate k √ó P</button>
                        <div id="realScalarResult"></div>
                    </div>
                    <div class="panel">
                        <h2>Visualization</h2>
                        <p style="margin-bottom: 15px; color: #888;">Visualization</p>
                        <canvas id="realMultiplicationCanvas" width="600" height="500"></canvas>
                        <label style="display:block; margin-top:8px; color:#aaa; font-size:0.95em;">
                            <input id="realMultiplicationShowLabels" type="checkbox" onchange="renderRealScalarAll()"> Show point labels
                        </label>
                        <div id="realAnimControls" class="anim-controls" style="display:none;"></div>
                    </div>
                </div>

                <div id="realHistoryPane" class="subtab-pane">
                    <div class="panel full-width">
                        <div class="history-controls">
                            <button onclick="refreshHistory('real')">Refresh</button>
                            <button onclick="clearHistory('real')">Clear All</button>
                        </div>
                        <div id="real-history-list" class="history-list"></div>
                    </div>
                </div>
            </div>

            <!-- Curve over Fp Tab -->
            <div id="fpTab" class="tab-pane active">
                <div class="panel full-width">
                    <h2>Curve over Fp</h2>
                    <div class="math-formula">y¬≤ = x¬≥ + ax + b (mod p)</div>
                    <div class="subtabs" style="margin-top:10px;">
                        <button class="subtab-btn active" data-subtab="fpInitPane" onclick="switchSubtab('fp','fpInitPane')">Initialization</button>
                        <button class="subtab-btn" data-subtab="fpAddPane" onclick="switchSubtab('fp','fpAddPane')">Point Addition</button>
                        <button class="subtab-btn" data-subtab="fpMulPane" onclick="switchSubtab('fp','fpMulPane')">Scalar Multiplication</button>
                        <button class="subtab-btn" data-subtab="fpHistoryPane" onclick="switchSubtab('fp','fpHistoryPane'); loadHistory('fp');">History</button>
                    </div>
                </div>

                <div id="fpInitPane" class="subtab-pane active">
                    <div class="panel">
                        <h2>Define Curve</h2>
                        <div class="form-group">
                            <div class="inline-inputs">
                                <div>
                                    <label for="paramA">a</label>
                                    <input type="number" id="paramA" value="2" placeholder="a">
                                </div>
                                <div>
                                    <label for="paramB">b</label>
                                    <input type="number" id="paramB" value="3" placeholder="b">
                                </div>
                                <div>
                                    <label for="paramP">p (prime)</label>
                                    <input type="number" id="paramP" value="97" placeholder="p">
                                </div>
                            </div>
                        </div>
                        <button onclick="findAllPoints()">Find All Points on Curve</button>
                    </div>
                    <div class="panel">
                        <h2>Points</h2>
                        <div id="curveInfo"></div>
                        <div id="pointsList"></div>
                    </div>
                </div>

                <div id="fpAddPane" class="subtab-pane">
                    <div class="panel">
                        <h2>Point Addition</h2>
                        <p style="margin-bottom: 15px; color: #888;">Add two points: P + Q = R</p>
                        <div class="form-group">
                            <label for="point1Select">Point P</label>
                            <select id="point1Select"><option value="">Select Point P</option></select>
                        </div>
                        <div class="form-group">
                            <label for="point2Select">Point Q</label>
                            <select id="point2Select"><option value="">Select Point Q</option></select>
                        </div>
                        <button onclick="addPoints()">Calculate P + Q</button>
                        <div id="additionResult"></div>
                    </div>
                    <div class="panel">
                        <h2>Visualization</h2>
                        <p style="margin-bottom: 15px; color: #888;">Points on the elliptic curve (mod p)</p>
                        <canvas id="additionCanvas" width="600" height="500"></canvas>
                        <label style="display:block; margin-top:8px; color:#aaa; font-size:0.95em;">
                            <input id="additionShowLabels" type="checkbox" onchange="redrawAdditionCanvas()"> Show point labels
                        </label>
                        <div id="additionPointInfo" class="point-info" aria-live="polite"></div>
                    </div>
                </div>

                <div id="fpMulPane" class="subtab-pane">
                    <div class="panel">
                        <h2>Scalar Multiplication</h2>
                        <p style="margin-bottom: 15px; color: #888;">Multiply a point by a scalar: k √ó P</p>
                        <div class="form-group">
                            <label for="scalarPointSelect">Point P</label>
                            <select id="scalarPointSelect"><option value="">Select Point P</option></select>
                        </div>
                        <div class="form-group">
                            <label for="scalarValue">Scalar k</label>
                            <input type="number" id="scalarValue" value="3" placeholder="k">
                        </div>
                        <button onclick="scalarMultiply()">Calculate k √ó P</button>
                        <div id="scalarResult"></div>
                    </div>
                    <div class="panel">
                        <h2>Visualization</h2>
                        <p style="margin-bottom: 15px; color: #888;">Visualization</p>
                        <canvas id="multiplicationCanvas" width="600" height="500"></canvas>
                        <label style="display:block; margin-top:8px; color:#aaa; font-size:0.95em;">
                            <input id="multiplicationShowLabels" type="checkbox" onchange="renderFpScalarAll()"> Show point labels
                        </label>
                        <div id="multiplicationPointInfo" class="point-info" aria-live="polite"></div>
                        <div id="animationControls" class="anim-controls" style="display:none;">
                            <button id="prevStepBtn" onclick="prevScalarStep()" disabled>Prev</button>
                            <button id="playPauseBtn" onclick="toggleScalarAnimation()" disabled>Play</button>
                            <input id="stepSlider" type="range" min="0" max="0" value="0" disabled oninput="onScalarSlider(this.value)">
                            <button id="nextStepBtn" onclick="nextScalarStep()" disabled>Next</button>
                            <span id="stepLabel" class="step-label">0/0</span>
                        </div>
                    </div>
                </div>

                <div id="fpHistoryPane" class="subtab-pane">
                    <div class="panel full-width">
                        <div class="history-controls">
                            <button onclick="refreshHistory('fp')">Refresh</button>
                            <button onclick="clearHistory('fp')">Clear All</button>
                        </div>
                        <div id="fp-history-list" class="history-list"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // NO IMPLEMENTATION CODE HERE!
        // All calculations are done by the backend

        let currentPoints = [];
        let currentCurve = {a: 2, b: 3, p: 97};
        let scalarSteps = [];
        let currentStep = 0;
        let animationInterval = null;
        let selectedAdditionIndex = null;
        let selectedMultiplicationIndex = null;

        // Tab switching
        function switchTab(tabId) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
            
            document.querySelector(`[data-tab="${tabId}"]`).classList.add('active');
            document.getElementById(tabId).classList.add('active');
            // Ensure canvases redraw when switching tabs
            redrawAllCurves();
            redrawRealCanvases();
        }

        function switchSubtab(group, paneId){
            const container = (group === 'real') ? document.getElementById('realTab') : document.getElementById('fpTab');
            if (!container) return;
            container.querySelectorAll('.subtab-btn').forEach(btn => btn.classList.remove('active'));
            container.querySelectorAll('.subtab-pane').forEach(p => p.classList.remove('active'));
            const btn = container.querySelector(`[data-subtab="${paneId}"]`);
            if (btn) btn.classList.add('active');
            const pane = document.getElementById(paneId);
            if (pane) pane.classList.add('active');
            if (group === 'real') { redrawRealCanvases(); } else { redrawAllCurves(); }
            // Load history when switching to history pane
            if (paneId === 'fpHistoryPane') loadHistory('fp');
            if (paneId === 'realHistoryPane') loadHistory('real');
        }

        // Setup canvas for HiDPI and return drawing context in CSS pixel units
        function setupCanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const cssWidth = canvas.clientWidth || canvas.width;
            const cssHeight = canvas.clientHeight || canvas.height;

            const targetWidth = Math.round(cssWidth * dpr);
            const targetHeight = Math.round(cssHeight * dpr);
            if (canvas.width !== targetWidth || canvas.height !== targetHeight) {
                canvas.width = targetWidth;
                canvas.height = targetHeight;
            }

            const ctx = canvas.getContext('2d');
            // Work in CSS pixels
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            return { ctx, cssWidth, cssHeight, dpr };
        }

        // Find all points - calls API
        async function findAllPoints() {
            const a = parseInt(document.getElementById('paramA').value);
            const b = parseInt(document.getElementById('paramB').value);
            const p = parseInt(document.getElementById('paramP').value);

            currentCurve = {a, b, p};
            const curveInfo = document.getElementById('curveInfo');
            curveInfo.innerHTML = '<p style="color: #888;">Calculating...</p>';

            try {
                const response = await fetch('/api/find_points', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({a, b, p})
                });

                const data = await response.json();

                if (data.success) {
                    currentPoints = data.points;
                    
                    curveInfo.innerHTML = `
                        <div class="curve-info">
                            <strong>Curve:</strong> <code>y¬≤ = x¬≥ + ${a}x + ${b} (mod ${p})</code><br>
                            <strong>Total Points:</strong> ${data.count}
                        </div>
                    `;

                    let html = '<div class="result-box"><h3>All Points on Curve</h3>';
                    data.points.forEach((point, index) => {
                        const className = point.display === 'O' ? 'point-item point-at-infinity' : 'point-item';
                        html += `<div class="${className}">${index + 1}. ${point.display}</div>`;
                    });
                    html += '</div>';
                    document.getElementById('pointsList').innerHTML = html;

                    populateSelectors();
                    // Draw points on canvases right away
                    redrawAllCurves();
                } else {
                    curveInfo.innerHTML = `<div class="error">${data.error}</div>`;
                }
            } catch (error) {
                curveInfo.innerHTML = `<div class="error">Connection error. Is the server running?</div>`;
            }
        }

        // Redraw helper to refresh both canvases with current points
        function redrawAllCurves() {
            const addCanvas = document.getElementById('additionCanvas');
            if (addCanvas) {
                const { ctx, cssWidth, cssHeight } = setupCanvas(addCanvas);
                ctx.clearRect(0, 0, cssWidth, cssHeight);
                drawAxesGrid(ctx, addCanvas);
                // Always draw base points without labels; labels for P,Q,R handled separately
                drawCurvePoints(ctx, addCanvas, '#8a8a8a', false);
                if (selectedAdditionIndex !== null && currentPoints[selectedAdditionIndex]) {
                    drawSelectedHighlight(ctx, addCanvas, currentPoints[selectedAdditionIndex]);
                }
            }

            const mulCanvas = document.getElementById('multiplicationCanvas');
            if (mulCanvas) {
                const { ctx, cssWidth, cssHeight } = setupCanvas(mulCanvas);
                ctx.clearRect(0, 0, cssWidth, cssHeight);
                drawAxesGrid(ctx, mulCanvas);
                drawCurvePoints(ctx, mulCanvas, '#8a8a8a', document.getElementById('multiplicationShowLabels')?.checked);
                if (selectedMultiplicationIndex !== null && currentPoints[selectedMultiplicationIndex]) {
                    drawSelectedHighlight(ctx, mulCanvas, currentPoints[selectedMultiplicationIndex]);
                }
            }
        }

        // Redraw the addition canvas specifically (used when toggling labels)
        function redrawAdditionCanvas() {
            // If we have a last computed addition, redraw with them; otherwise just base grid + points
            if (window._lastAdditionP && window._lastAdditionQ && window._lastAdditionR) {
                visualizeAddition(window._lastAdditionP, window._lastAdditionQ, window._lastAdditionR);
            } else {
                const canvas = document.getElementById('additionCanvas');
                const { ctx, cssWidth, cssHeight } = setupCanvas(canvas);
                ctx.clearRect(0, 0, cssWidth, cssHeight);
                drawAxesGrid(ctx, canvas);
                // Always draw base points without labels; labels are applied only to P,Q,R
                drawCurvePoints(ctx, canvas, '#8a8a8a', false);
                if (selectedAdditionIndex !== null && currentPoints[selectedAdditionIndex]) {
                    drawSelectedHighlight(ctx, canvas, currentPoints[selectedAdditionIndex]);
                }
            }
        }

        function populateSelectors() {
            const selectors = ['point1Select', 'point2Select', 'scalarPointSelect'];
            
            selectors.forEach(id => {
                const select = document.getElementById(id);
                select.innerHTML = '<option value="">Select a point</option>';
                
                currentPoints.forEach((point, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = point.display;
                    select.appendChild(option);
                });
            });
        }

        // Add points - calls API
        async function addPoints() {
            const p1Index = document.getElementById('point1Select').value;
            const p2Index = document.getElementById('point2Select').value;
            const resultDiv = document.getElementById('additionResult');

            if (!p1Index || !p2Index) {
                resultDiv.innerHTML = '<div class="error">Please select both points</div>';
                return;
            }

                resultDiv.innerHTML = '<p style="color: #888;">Calculating...</p>';

            try {
                const response = await fetch('/api/add_points', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        a: currentCurve.a,
                        b: currentCurve.b,
                        p: currentCurve.p,
                        p1: currentPoints[p1Index],
                        p2: currentPoints[p2Index]
                    })
                });

                const data = await response.json();

                if (data.success) {
                    resultDiv.innerHTML = `
                        <div class="operation-result">
                            <strong>P</strong> = ${currentPoints[p1Index].display}<br>
                            <strong>Q</strong> = ${currentPoints[p2Index].display}<br>
                            <strong>P + Q</strong> = ${data.result.display}
                        </div>
                    `;
                    // store for re-rendering with label toggle
                    window._lastAdditionP = currentPoints[p1Index];
                    window._lastAdditionQ = currentPoints[p2Index];
                    window._lastAdditionR = data.result;
                    visualizeAddition(window._lastAdditionP, window._lastAdditionQ, window._lastAdditionR);
                    // animate addition pulse
                    startFpAdditionAnimation(window._lastAdditionP, window._lastAdditionQ, window._lastAdditionR);
                } else {
                    resultDiv.innerHTML = `<div class="error">${data.error}</div>`;
                }
            } catch (error) {
                resultDiv.innerHTML = '<div class="error">Connection error</div>';
            }
        }

        // Scalar multiplication - calls API (Fp)
        let fpScalarPoints = [];
        let _fpMulAnim = { active:false, raf:null };
        async function scalarMultiply() {
            const pointIndex = document.getElementById('scalarPointSelect').value;
            const k = parseInt(document.getElementById('scalarValue').value);
            const resultDiv = document.getElementById('scalarResult');

            if (!pointIndex) {
                resultDiv.innerHTML = '<div class="error">Please select a point</div>';
                return;
            }

            if (isNaN(k)) {
                resultDiv.innerHTML = '<div class="error">Please enter a valid scalar</div>';
                return;
            }

            resultDiv.innerHTML = '<p style="color: #888;">Calculating...</p>';

            try {
                const response = await fetch('/api/scalar_multiply', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        a: currentCurve.a,
                        b: currentCurve.b,
                        p: currentCurve.p,
                        k: k,
                        point: currentPoints[pointIndex]
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // Show only final result coordinates
                    resultDiv.innerHTML = `
                        <div class="operation-result">
                            <strong>P</strong> = ${currentPoints[pointIndex].display}<br>
                            <strong>k</strong> = ${k}<br>
                            <strong>${k} √ó P</strong> = ${data.result.display}
                        </div>
                    `;

                    // Parse intermediate multiples into points array and draw all
                    scalarSteps = data.steps || [];
                    fpScalarPoints = [];
                    const re = /\((\d+)\s*,\s*(\d+)\)/;
                    for (const s of scalarSteps) {
                        const m = re.exec(s || '');
                        if (m) fpScalarPoints.push({ x: parseInt(m[1]), y: parseInt(m[2]) });
                    }
                    // Animate plotting of 1P..kP
                    startFpMultiplicationAnimation();
                } else {
                    resultDiv.innerHTML = `<div class="error">${data.error}</div>`;
                }
            } catch (error) {
                resultDiv.innerHTML = '<div class="error">Connection error</div>';
            }
        }

        // Animation controls
        function prevScalarStep() {
            if (currentStep > 0) {
                currentStep--;
                document.getElementById('stepSlider').value = currentStep;
                visualizeScalarStep(currentStep);
                updateStepLabel();
            }
        }

        function nextScalarStep() {
            if (currentStep < scalarSteps.length - 1) {
                currentStep++;
                document.getElementById('stepSlider').value = currentStep;
                visualizeScalarStep(currentStep);
                updateStepLabel();
            }
        }

        function onScalarSlider(value) {
            currentStep = parseInt(value);
            visualizeScalarStep(currentStep);
            updateStepLabel();
        }

        function toggleScalarAnimation() {
            const btn = document.getElementById('playPauseBtn');
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
                btn.textContent = 'Play';
            } else {
                btn.textContent = 'Pause';
                animationInterval = setInterval(() => {
                    if (currentStep < scalarSteps.length - 1) {
                        nextScalarStep();
                    } else {
                        clearInterval(animationInterval);
                        animationInterval = null;
                        btn.textContent = 'Play';
                        currentStep = 0;
                    }
                }, 1000);
            }
        }

        function updateStepLabel() {
            document.getElementById('stepLabel').textContent = `${currentStep + 1}/${scalarSteps.length}`;
        }

        // Visualization functions
        function visualizeAddition(P, Q, R) {
            const canvas = document.getElementById('additionCanvas');
            const { ctx, cssWidth, cssHeight } = setupCanvas(canvas);
            ctx.clearRect(0, 0, cssWidth, cssHeight);
            
            drawAxesGrid(ctx, canvas);
            // Always draw full curve points without labels
            drawCurvePoints(ctx, canvas, '#8a8a8a', false);
            
            // Highlight P, Q, R
            if (P.x !== null) {
                drawPoint(ctx, canvas, P.x, P.y, '#667eea', 6, 'P');
            }
            if (Q.x !== null) {
                drawPoint(ctx, canvas, Q.x, Q.y, '#764ba2', 6, 'Q');
            }
            if (R.x !== null) {
                drawPoint(ctx, canvas, R.x, R.y, '#667eea', 7, 'R');
            }

            // Selected point highlight (click)
            if (selectedAdditionIndex !== null && currentPoints[selectedAdditionIndex]) {
                drawSelectedHighlight(ctx, canvas, currentPoints[selectedAdditionIndex]);
            }

            // If toggled, show coordinates only for the answer-related points P, Q, and R
            const showA = document.getElementById('additionShowLabels')?.checked;
            if (showA) {
                const padding = 50;
                const cssWidth = (canvas.clientWidth || canvas.width);
                const cssHeight = (canvas.clientHeight || canvas.height);
                const width = cssWidth - 2 * padding;
                const height = cssHeight - 2 * padding;
                const maxVal = Math.max(1, (currentCurve.p || 1) - 1);
                function drawCoords(pt){
                    if (!pt || pt.x === null || pt.y === null) return;
                    const x = padding + (pt.x / maxVal) * width;
                    const y = cssHeight - padding - (pt.y / maxVal) * height;
                    const label = `(${pt.x}, ${pt.y})`;
                    ctx.font = '10px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fillText(label, x, y - 10 + 1);
                    ctx.fillStyle = '#bbb';
                    ctx.fillText(label, x, y - 10);
                }
                drawCoords(P);
                drawCoords(Q);
                drawCoords(R);
            }
        }

        // Pulse animation for Fp addition
        let _fpAddAnim = { active:false, raf:null, started:0, duration:1300 };
        function startFpAdditionAnimation(P, Q, R){
            const canvas = document.getElementById('additionCanvas');
            if (!canvas) return;
            if (_fpAddAnim.raf) cancelAnimationFrame(_fpAddAnim.raf);
            _fpAddAnim = { active:true, raf:null, started: performance.now(), duration:1300 };
            const map = (px, py) => {
                const padding = 50;
                const cssWidth = (canvas.clientWidth || canvas.width);
                const cssHeight = (canvas.clientHeight || canvas.height);
                const width = cssWidth - 2 * padding;
                const height = cssHeight - 2 * padding;
                const maxVal = Math.max(1, (currentCurve.p || 1) - 1);
                const x = padding + (px / maxVal) * width;
                const y = cssHeight - padding - (py / maxVal) * height;
                return {x, y};
            };
            const tick = (now)=>{
                const { ctx, cssWidth, cssHeight } = setupCanvas(canvas);
                ctx.clearRect(0,0,cssWidth,cssHeight);
                drawAxesGrid(ctx, canvas);
                drawCurvePoints(ctx, canvas, '#8a8a8a', document.getElementById('additionShowLabels')?.checked);
                if (P.x !== null) drawPoint(ctx, canvas, P.x, P.y, '#667eea', 6, 'P');
                if (Q.x !== null) drawPoint(ctx, canvas, Q.x, Q.y, '#764ba2', 6, 'Q');
                if (R.x !== null) drawPoint(ctx, canvas, R.x, R.y, '#667eea', 7, 'R');
                const t = Math.min(1, (now - _fpAddAnim.started) / _fpAddAnim.duration);
                const pulse = (base, color)=>{
                    ctx.strokeStyle = color; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(base.x, base.y, 10 + 8*Math.sin(t*Math.PI), 0, 2*Math.PI); ctx.stroke();
                };
                if (P.x !== null){ const p = map(P.x, P.y); pulse(p, '#667eea'); }
                if (Q.x !== null){ const q = map(Q.x, Q.y); pulse(q, '#764ba2'); }
                if (R.x !== null && t>0.5){ const r = map(R.x, R.y); pulse(r, '#e6e6e6'); }
                if (t < 1){ _fpAddAnim.raf = requestAnimationFrame(tick); }
                else { _fpAddAnim.active = false; _fpAddAnim.raf = null; visualizeAddition(P, Q, R); }
            };
            _fpAddAnim.raf = requestAnimationFrame(tick);
        }

        function renderFpScalarAll() {
            const canvas = document.getElementById('multiplicationCanvas');
            if (!canvas) return;
            const { ctx, cssWidth, cssHeight } = setupCanvas(canvas);
            ctx.clearRect(0, 0, cssWidth, cssHeight);
            drawAxesGrid(ctx, canvas);
            // Always show the full discrete curve points (no labels)
            drawCurvePoints(ctx, canvas, '#8a8a8a', false);

            // Then draw the multiples (answer-related points)
            const showCoords = document.getElementById('multiplicationShowLabels')?.checked;

            // Precompute mapping helpers for coordinate label placement
            const padding = 50;
            const cW = (canvas.clientWidth || canvas.width);
            const cH = (canvas.clientHeight || canvas.height);
            const width = cW - 2 * padding;
            const height = cH - 2 * padding;
            const maxVal = Math.max(1, (currentCurve.p || 1) - 1);

            fpScalarPoints.forEach((pt, i) => {
                if (pt && pt.x !== null) {
                    // Always label points as 1P, 2P, ...
                    const lbl = `${i+1}P`;
                    drawPoint(ctx, canvas, pt.x, pt.y, '#e6e6e6', 6, lbl);

                     // If toggled, also show coordinates for these multiples only
                     if (showCoords) {
                        const x = padding + (pt.x / maxVal) * width;
                        const y = cH - padding - (pt.y / maxVal) * height;
                        const coord = `(${pt.x}, ${pt.y})`;
                        ctx.font = '10px monospace';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.fillStyle = 'rgba(0,0,0,0.6)';
                        ctx.fillText(coord, x, y - 10 + 1);
                        ctx.fillStyle = '#bbb';
                        ctx.fillText(coord, x, y - 10);
                    }
                }
            });

            if (selectedMultiplicationIndex !== null && currentPoints[selectedMultiplicationIndex]) {
                drawSelectedHighlight(ctx, canvas, currentPoints[selectedMultiplicationIndex]);
            }
        }

        function renderFpScalarPartial(count) {
            const canvas = document.getElementById('multiplicationCanvas');
            if (!canvas) return;
            const { ctx, cssWidth, cssHeight } = setupCanvas(canvas);
            ctx.clearRect(0, 0, cssWidth, cssHeight);
            drawAxesGrid(ctx, canvas);
            drawCurvePoints(ctx, canvas, '#8a8a8a', false);

            const padding = 50;
            const cW = (canvas.clientWidth || canvas.width);
            const cH = (canvas.clientHeight || canvas.height);
            const width = cW - 2 * padding;
            const height = cH - 2 * padding;
            const maxVal = Math.max(1, (currentCurve.p || 1) - 1);

            const n = Math.min(count, fpScalarPoints.length);
            for (let i=0;i<n;i++){
                const pt = fpScalarPoints[i];
                if (!pt || pt.x === null) continue;
                const lbl = `${i+1}P`;
                drawPoint(ctx, canvas, pt.x, pt.y, '#e6e6e6', 6, lbl);
            }
        }

        function startFpMultiplicationAnimation(){
            if (!fpScalarPoints || !fpScalarPoints.length) { renderFpScalarAll(); return; }
            if (_fpMulAnim.raf) cancelAnimationFrame(_fpMulAnim.raf);
            _fpMulAnim.active = true;
            const start = performance.now();
            const per = 280; // ms per point
            const tick = (now)=>{
                const elapsed = now - start;
                const shown = Math.min(fpScalarPoints.length, Math.floor(elapsed / per) + 1);
                renderFpScalarPartial(shown);
                if (shown < fpScalarPoints.length) {
                    _fpMulAnim.raf = requestAnimationFrame(tick);
                } else {
                    _fpMulAnim.active = false; _fpMulAnim.raf = null;
                    renderFpScalarAll();
                }
            };
            _fpMulAnim.raf = requestAnimationFrame(tick);
        }

        function drawCurvePoints(ctx, canvas, color, showLabels=false) {
            const padding = 50;
            const cssWidth = (canvas.clientWidth || canvas.width);
            const cssHeight = (canvas.clientHeight || canvas.height);
            const width = cssWidth - 2 * padding;
            const height = cssHeight - 2 * padding;
            const maxVal = Math.max(1, (currentCurve.p || 1) - 1);
            
            currentPoints.forEach(point => {
                if (point.x !== null) {
                    const x = padding + (point.x / maxVal) * width;
                    const y = cssHeight - padding - (point.y / maxVal) * height;
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();

                    if (showLabels) {
                        ctx.fillStyle = '#bbb';
                        ctx.font = '10px monospace';
                        ctx.fillText(`(${point.x},${point.y})`, x + 12, y - 12);
                    }
                }
            });
        }

        function drawPoint(ctx, canvas, px, py, color, size, label=null) {
            const padding = 50;
            const cssWidth = (canvas.clientWidth || canvas.width);
            const cssHeight = (canvas.clientHeight || canvas.height);
            const width = cssWidth - 2 * padding;
            const height = cssHeight - 2 * padding;
            const maxVal = Math.max(1, (currentCurve.p || 1) - 1);
            
            const x = padding + (px / maxVal) * width;
            const y = cssHeight - padding - (py / maxVal) * height;
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, size + 3, 0, 2 * Math.PI);
            ctx.stroke();

            if (label) {
                ctx.fillStyle = color;
                ctx.font = '12px Arial';
                ctx.fillText(`${label}`, x + size + 10, y - size - 10);
            }
        }

        function drawSelectedHighlight(ctx, canvas, point) {
            if (!point || point.x === null || point.y === null) return;
            const padding = 50;
            const cssWidth = (canvas.clientWidth || canvas.width);
            const cssHeight = (canvas.clientHeight || canvas.height);
            const width = cssWidth - 2 * padding;
            const height = cssHeight - 2 * padding;
            const maxVal = Math.max(1, (currentCurve.p || 1) - 1);

            const px = padding + (point.x / maxVal) * width;
            const py = cssHeight - padding - (point.y / maxVal) * height;

            // Draw red highlight point
            const color = '#f44336';
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(px, py, 7, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(px, py, 10, 0, 2 * Math.PI);
            ctx.stroke();

            // Draw coordinates above the point
            const label = `(${point.x}, ${point.y})`;
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            // slight shadow for readability
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillText(label, px, py - 12 + 1);
            ctx.fillStyle = color;
            ctx.fillText(label, px, py - 12);
        }

        function drawAxesGrid(ctx, canvas) {
            const padding = 50;
            const cssWidth = (canvas.clientWidth || canvas.width);
            const cssHeight = (canvas.clientHeight || canvas.height);
            const width = cssWidth - 2 * padding;
            const height = cssHeight - 2 * padding;
            const maxVal = Math.max(1, (currentCurve.p || 1) - 1);

            // Border
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(padding, padding, width, height);

            // Grid and ticks
            const desiredTicks = 8;
            const step = Math.max(1, Math.ceil(maxVal / desiredTicks));
            ctx.fillStyle = '#888';
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            for (let t = 0; t <= maxVal; t += step) {
                const x = padding + (t / maxVal) * width;
                const y = padding + (1 - t / maxVal) * height; // for y-axis labels
                // vertical grid line
                ctx.strokeStyle = 'rgba(255,255,255,0.06)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, padding + height);
                ctx.stroke();
                // x tick label
                ctx.fillStyle = '#888';
                ctx.fillText(`${t}`, x, padding + height + 6);
                // horizontal grid line
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + width, y);
                ctx.stroke();
                // y tick label
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${t}`, padding - 6, y);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
            }
            // Axis titles
            ctx.fillStyle = '#aaa';
            ctx.font = '11px Arial';
            ctx.fillText('x', padding + width, padding + height + 20);
            ctx.save();
            ctx.translate(padding - 20, padding);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('y', 0, 0);
            ctx.restore();
        }

        // Load initial curve and handle resize for crisp rendering
        window.onload = () => {
            // If forced login, ensure overlay is visible before any heavy work
            if (shouldForceLogin()) {
                const ov = document.getElementById('authOverlay');
                if (ov) ov.classList.add('visible');
            }
            findAllPoints();
            window.addEventListener('resize', () => {
                redrawAllCurves();
                redrawRealCanvases();
            });
            attachCanvasClickHandlers();
            attachRealCanvasHandlers();
            loadSession();
        };

        // Attach click handlers to canvases to show coordinates
        function attachCanvasClickHandlers() {
            const addCanvas = document.getElementById('additionCanvas');
            const mulCanvas = document.getElementById('multiplicationCanvas');

            if (addCanvas) {
                addCanvas.addEventListener('click', (e) => handleCanvasClick(e, addCanvas, 'additionPointInfo'));
            }
            if (mulCanvas) {
                mulCanvas.addEventListener('click', (e) => handleCanvasClick(e, mulCanvas, 'multiplicationPointInfo'));
            }
        }

        // Auth UI & API integration
        function shouldForceLogin(){
            try { if (localStorage.getItem('force_login') === '1') return true; } catch(_) {}
            const qs = new URLSearchParams(window.location.search);
            return qs.get('login') === '1';
        }

        async function loadSession() {
            try {
                const res = await fetch('/api/session');
                const data = await res.json();
                const force = shouldForceLogin();
                updateAuthUI(data);
                if (!data || !data.logged_in) {
                    if (!force) ensureGuestSession();
                }
            } catch (e) {
                // attempt guest if session fetch fails (unless we force login view)
                if (!shouldForceLogin()) ensureGuestSession();
            }
        }

        function updateAuthUI(session) {
            const overlay = document.getElementById('authOverlay');
            const profileBtn = document.getElementById('profileBtn');
            const profileName = document.getElementById('profileName');
            const isLoggedIn = !!(session && session.logged_in);
            const isGuest = !!(session && session.is_guest);
            const forceLogin = shouldForceLogin();
            // If forced login, show overlay even if currently a guest
            if (forceLogin && (!isLoggedIn || isGuest)) {
                if (overlay) overlay.classList.add('visible');
                if (profileBtn) profileBtn.style.display = 'none';
                // If currently guest, log out to clear session
                if (isGuest) { fetch('/api/logout', {method:'POST'}).catch(()=>{}); }
                try { localStorage.removeItem('force_login'); } catch(_) {}
                return;
            }
            // Default: do not auto-show overlay; we prefer guest by default
            if (overlay) overlay.classList.remove('visible');
            if (profileBtn) profileBtn.style.display = 'inline-flex';
            if (profileName) profileName.textContent = isLoggedIn ? `${session.username || 'user'}${isGuest ? ' (guest)' : ''}` : 'guest';
            const menuLogin = document.getElementById('menuLogin');
            const menuLogout = document.getElementById('menuLogout');
            if (menuLogin) menuLogin.style.display = isGuest ? 'block' : 'none';
            if (menuLogout) menuLogout.style.display = (isLoggedIn && !isGuest) ? 'block' : 'none';
        }

        // Auto-create a guest session on first load
        let _guestAttempted = false;
        async function ensureGuestSession(){
            if (_guestAttempted) return; _guestAttempted = true;
            try {
                let res = await fetch('/api/auth/guest', {method:'POST'});
                if(!res.ok){ res = await fetch('/api/guest', {method:'POST'}); }
                loadSession();
            } catch(_){ /* ignore */ }
        }

        function openLoginModal(){
            const overlay = document.getElementById('authOverlay');
            if (overlay) overlay.classList.add('visible');
        }

        // Username-only auth: simple non-empty check
        function setErr(id, msg){ const el = document.getElementById(id); if(!el) return; el.textContent = msg||''; el.style.display = msg? 'block':'none'; }

        // Removed legacy overlay login/signup functions to reduce duplication

        // New card handlers following spec
        async function submitLoginCard(){
            const username = document.getElementById('loginUsername').value.trim();
            const password = document.getElementById('loginPassword').value;
            const msgEl = document.getElementById('authMsgOverlay');
            setErr('loginUsernameErr', !username? 'Username is required': '');
            setErr('loginPasswordErr', !password? 'Password is required': '');
            if(!username || !password) return;
            msgEl.textContent = 'Logging in...';
            // Try /api/auth/login then fallback to /api/login
            const payload = {username, password};
            try {
                let res = await fetch('/api/auth/login', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
                if(!res.ok){
                    res = await fetch('/api/login', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
                }
                const data = await res.json();
                if(!res.ok || !data.success){
                    msgEl.textContent = data.message || 'Invalid credentials';
                    return;
                }
                msgEl.textContent = '';
                // Redirect to /app
                window.location.href = '/app';
            } catch(e){
                msgEl.textContent = 'Login error';
            }
        }

        function openSignupPage(){ window.location.href = '/signup'; }

        async function continueAsGuestCard(){
            const msgEl = document.getElementById('authMsgOverlay');
            msgEl.textContent = '';
            try {
                let res = await fetch('/api/auth/guest', {method:'POST'});
                if(!res.ok){ res = await fetch('/api/guest', {method:'POST'}); }
                if(res.ok){ window.location.href = '/app'; return; }
            } catch(_){}
            try { localStorage.setItem('guest_session_id', (crypto && crypto.randomUUID? crypto.randomUUID(): String(Date.now()))); } catch(_) {}
            window.location.href = '/app';
        }

        async function doLogout() {
            try {
                await fetch('/api/logout', {method: 'POST'});
                loadSession();
            } catch (e) { /* ignore */ }
        }

        // removed legacy continueAsGuest()

        // Profile menu
        function toggleProfileMenu() {
            const menu = document.getElementById('profileMenu');
            const btn = document.getElementById('profileBtn');
            const visible = !menu.classList.contains('visible');
            if (visible) menu.classList.add('visible'); else menu.classList.remove('visible');
            btn.setAttribute('aria-expanded', visible ? 'true' : 'false');
        }
        function hideProfileMenu() {
            const menu = document.getElementById('profileMenu');
            const btn = document.getElementById('profileBtn');
            if (menu) menu.classList.remove('visible');
            if (btn) btn.setAttribute('aria-expanded', 'false');
        }
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('profileMenu');
            const btn = document.getElementById('profileBtn');
            if (!menu || !btn) return;
            if (!menu.contains(e.target) && !btn.contains(e.target)) hideProfileMenu();
        });

        // (unused) legacy auth view toggling removed

        function handleCanvasClick(event, canvas, infoId) {
            if (!currentPoints || currentPoints.length === 0) return;

            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            const idx = findNearestPointIndex(canvas, clickX, clickY);
            const info = document.getElementById(infoId);
            // Clear any text info; we draw labels inside the canvas instead
            if (info) info.textContent = '';

            if (canvas.id === 'additionCanvas') {
                selectedAdditionIndex = idx;
                if (window._lastAdditionP && window._lastAdditionQ && window._lastAdditionR && idx !== null) {
                    visualizeAddition(window._lastAdditionP, window._lastAdditionQ, window._lastAdditionR);
                } else {
                    redrawAdditionCanvas();
                }
            } else if (canvas.id === 'multiplicationCanvas') {
                selectedMultiplicationIndex = idx;
                renderFpScalarAll();
            }
        }

        function findNearestPointIndex(canvas, clickX, clickY) {
            const padding = 50;
            const cssWidth = (canvas.clientWidth || canvas.width);
            const cssHeight = (canvas.clientHeight || canvas.height);
            const width = cssWidth - 2 * padding;
            const height = cssHeight - 2 * padding;
            const maxVal = Math.max(1, (currentCurve.p || 1) - 1);

            let bestIdx = null;
            let bestDist2 = Infinity;
            const threshold = 10; // px radius for selection

            for (let i = 0; i < currentPoints.length; i++) {
                const point = currentPoints[i];
                if (point.x === null || point.y === null) continue; // skip point at infinity
                const x = padding + (point.x / maxVal) * width;
                const y = cssHeight - padding - (point.y / maxVal) * height;
                const dx = x - clickX;
                const dy = y - clickY;
                const d2 = dx * dx + dy * dy;
                if (d2 < bestDist2) {
                    bestDist2 = d2;
                    bestIdx = i;
                }
            }

            if (bestIdx !== null && bestDist2 <= threshold * threshold) {
                return bestIdx;
            }
            return null;
        }

        // =================== REAL CURVES (over R) =================== //
        let realCurve = { a: -1, b: 1 };
        let realRange = { xMin: -10, xMax: 10, yMin: -10, yMax: 10 };
        let realP = null; // {x,y}
        let realQ = null; // {x,y}
        let realR = null; // {x,y}
        let realScalarSteps = [];
        let realScalarPoints = [];
        let realCurrentStep = 0;
        let realAnimInterval = null;
        let realPickPhase = 'P';

        async function initRealCurve(){
            const a = parseFloat(document.getElementById('realParamA').value);
            const b = parseFloat(document.getElementById('realParamB').value);
            try {
                const res = await fetch('/api/init_real_curve', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({a, b}) });
                const data = await res.json();
                if (!res.ok || !data.success) {
                    alert(data.error || 'Invalid curve');
                    return;
                }
                realCurve = {a, b};
                // Read desired symmetric range from inputs: x,y ‚àà [min, max]
                const rmin = parseFloat(document.getElementById('realRangeMin').value);
                const rmax = parseFloat(document.getElementById('realRangeMax').value);
                if ([rmin,rmax].some(v => Number.isNaN(v))) {
                    alert('Please enter valid numeric ranges');
                    return;
                }
                if (!(rmin < rmax)){
                    alert('Range must satisfy min < max');
                    return;
                }
                realRange = { xMin: rmin, xMax: rmax, yMin: rmin, yMax: rmax };
                // reset selections
                realP = null; realQ = null; realR = null;
                redrawRealCanvases();
                startRealCurveDrawAnimation();
            } catch(e){ alert('Connection error'); }
        }

        function attachRealCanvasHandlers(){
            const addCanvas = document.getElementById('realAdditionCanvas');
            if (addCanvas){
                addCanvas.addEventListener('click', (e) => handleRealAdditionClick(e, addCanvas));
            }
            const mulCanvas = document.getElementById('realMultiplicationCanvas');
            if (mulCanvas){
                mulCanvas.addEventListener('click', (e) => handleRealMultiplicationClick(e, mulCanvas));
            }
        }

        function redrawRealCanvases(){
            drawRealCurveOnly();
            drawRealAdditionScene();
            visualizeRealScalarStep(realCurrentStep);
        }

        function mapRealToCanvas(canvas, x, y){
            const padding = 50;
            const cssWidth = (canvas.clientWidth || canvas.width);
            const cssHeight = (canvas.clientHeight || canvas.height);
            const width = cssWidth - 2 * padding;
            const height = cssHeight - 2 * padding;
            const px = padding + (x - realRange.xMin) * (width / (realRange.xMax - realRange.xMin));
            const py = cssHeight - padding - (y - realRange.yMin) * (height / (realRange.yMax - realRange.yMin));
            return {px, py};
        }

        function drawRealAxesGrid(ctx, canvas){
            const padding = 50;
            const cssWidth = (canvas.clientWidth || canvas.width);
            const cssHeight = (canvas.clientHeight || canvas.height);
            const width = cssWidth - 2 * padding;
            const height = cssHeight - 2 * padding;

            // Border
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(padding, padding, width, height);

            // Grid and ticks
            const desiredTicks = 8;
            const xRange = realRange.xMax - realRange.xMin;
            const yRange = realRange.yMax - realRange.yMin;
            const xStep = niceStep(xRange / desiredTicks);
            const yStep = niceStep(yRange / desiredTicks);

            ctx.fillStyle = '#888';
            ctx.font = '10px monospace';

            // Vertical grid + ticks
            for (let x = Math.ceil(realRange.xMin / xStep) * xStep; x <= realRange.xMax + 1e-9; x += xStep){
                const {px} = mapRealToCanvas(canvas, x, 0);
                ctx.strokeStyle = 'rgba(255,255,255,0.06)';
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(px, padding); ctx.lineTo(px, padding + height); ctx.stroke();
                ctx.fillStyle = '#888';
                ctx.textAlign = 'center'; ctx.textBaseline = 'top';
                ctx.fillText(formatNum(x), px, padding + height + 6);
            }
            // Horizontal grid + ticks
            for (let y = Math.ceil(realRange.yMin / yStep) * yStep; y <= realRange.yMax + 1e-9; y += yStep){
                const {py} = mapRealToCanvas(canvas, 0, y);
                ctx.strokeStyle = 'rgba(255,255,255,0.06)';
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(padding, py); ctx.lineTo(padding + width, py); ctx.stroke();
                ctx.fillStyle = '#888';
                ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
                ctx.fillText(formatNum(y), padding - 6, py);
            }
            // Axes at 0
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 1.5;
            // x-axis
            if (realRange.yMin < 0 && realRange.yMax > 0){
                const {py} = mapRealToCanvas(canvas, 0, 0);
                ctx.beginPath(); ctx.moveTo(padding, py); ctx.lineTo(padding + width, py); ctx.stroke();
            }
            // y-axis
            if (realRange.xMin < 0 && realRange.xMax > 0){
                const {px} = mapRealToCanvas(canvas, 0, 0);
                ctx.beginPath(); ctx.moveTo(px, padding); ctx.lineTo(px, padding + height); ctx.stroke();
            }
            // Axis titles
            ctx.fillStyle = '#aaa';
            ctx.font = '11px Arial';
            ctx.fillText('x', padding + width, padding + height + 20);
            ctx.save(); ctx.translate(padding - 20, padding); ctx.rotate(-Math.PI/2); ctx.fillText('y', 0, 0); ctx.restore();
        }

        function niceStep(raw){
            const pow10 = Math.pow(10, Math.floor(Math.log10(raw||1)));
            const frac = raw / pow10;
            let nice;
            if (frac < 1.5) nice = 1; else if (frac < 3) nice = 2; else if (frac < 7) nice = 5; else nice = 10;
            return nice * pow10;
        }
        function formatNum(n){
            const s = Math.abs(n) >= 1e4 || (Math.abs(n)>0 && Math.abs(n)<1e-3) ? n.toExponential(1) : (Math.round(n*100)/100).toString();
            return s;
        }

        // Track animation state for real curve initial draw
        let _realCurveAnim = { active:false, raf:null, t:0 };

        function drawRealCurveOnly(){
            const canvas = document.getElementById('realCurveCanvas');
            if (!canvas) return;
            const { ctx, cssWidth, cssHeight } = setupCanvas(canvas);
            ctx.clearRect(0,0,cssWidth,cssHeight);
            drawRealAxesGrid(ctx, canvas);
            drawRealCurve(ctx, canvas, realCurve.a, realCurve.b, _realCurveAnim.active ? Math.min(1,_realCurveAnim.t) : 1);
        }

        function drawRealCurve(ctx, canvas, a, b, progress=1){
            // Sample x values and draw y=+sqrt and y=-sqrt branches
            const steps = 800;
            const endI = Math.max(0, Math.floor(steps * Math.max(0, Math.min(1, progress))));
            let prevTop = null, prevBot = null;
            for (let i=0;i<=endI;i++){
                const x = realRange.xMin + (i/steps)*(realRange.xMax - realRange.xMin);
                const y2 = x*x*x + a*x + b;
                if (y2 >= 0){
                    const yTop = Math.sqrt(y2);
                    const yBot = -yTop;
                    const {px: pxTop, py: pyTop} = mapRealToCanvas(canvas, x, yTop);
                    const {px: pxBot, py: pyBot} = mapRealToCanvas(canvas, x, yBot);
                    ctx.strokeStyle = '#8a8a8a';
                    ctx.lineWidth = 2;
                    if (prevTop){ ctx.beginPath(); ctx.moveTo(prevTop.x, prevTop.y); ctx.lineTo(pxTop, pyTop); ctx.stroke(); }
                    if (prevBot){ ctx.beginPath(); ctx.moveTo(prevBot.x, prevBot.y); ctx.lineTo(pxBot, pyBot); ctx.stroke(); }
                    prevTop = {x: pxTop, y: pyTop};
                    prevBot = {x: pxBot, y: pyBot};
                } else {
                    prevTop = null; prevBot = null;
                }
            }
        }

        function startRealCurveDrawAnimation(){
            if (_realCurveAnim.raf) cancelAnimationFrame(_realCurveAnim.raf);
            _realCurveAnim = { active:true, raf:null, t:0 };
            const start = performance.now();
            const duration = 900;
            const step = (now)=>{
                _realCurveAnim.t = Math.min(1, (now - start)/duration);
                drawRealCurveOnly();
                if (_realCurveAnim.t < 1) _realCurveAnim.raf = requestAnimationFrame(step);
                else { _realCurveAnim.active=false; _realCurveAnim.raf=null; }
            };
            _realCurveAnim.raf = requestAnimationFrame(step);
        }

        function handleRealAdditionClick(event, canvas){
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;
            // Map click to x, then pick nearest y on curve at that x
            const padding = 50;
            const cssWidth = (canvas.clientWidth || canvas.width);
            const cssHeight = (canvas.clientHeight || canvas.height);
            const width = cssWidth - 2*padding;
            const height = cssHeight - 2*padding;
            const x = realRange.xMin + ((clickX - padding) / width) * (realRange.xMax - realRange.xMin);
            const y2 = x*x*x + realCurve.a*x + realCurve.b;
            if (y2 < 0) { return; }
            const yTop = Math.sqrt(y2);
            const yBot = -yTop;
            // decide which branch is closer to click
            const topPy = cssHeight - padding - ( (yTop - realRange.yMin) * (height/(realRange.yMax - realRange.yMin)) );
            const botPy = cssHeight - padding - ( (yBot - realRange.yMin) * (height/(realRange.yMax - realRange.yMin)) );
            const pickY = (Math.abs(topPy - clickY) < Math.abs(botPy - clickY)) ? yTop : yBot;

            const modeEl = document.getElementById('realSelectMode');
            const mode = realPickPhase || (modeEl?.value) || 'P';
            if (mode === 'P') {
                realP = {x, y: pickY};
                document.getElementById('realP1X').value = x; document.getElementById('realP1Y').value = pickY;
                realPickPhase = 'Q'; if (modeEl) modeEl.value = 'Q';
            } else {
                realQ = {x, y: pickY};
                document.getElementById('realP2X').value = x; document.getElementById('realP2Y').value = pickY;
                realPickPhase = 'P'; if (modeEl) modeEl.value = 'P';
            }
            drawRealAdditionScene();
        }

        function handleRealMultiplicationClick(event, canvas){
            // Map click to a point on the curve and set P for scalar multiplication
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;
            const padding = 50;
            const cssWidth = (canvas.clientWidth || canvas.width);
            const cssHeight = (canvas.clientHeight || canvas.height);
            const width = cssWidth - 2*padding;
            const height = cssHeight - 2*padding;

            const x = realRange.xMin + ((clickX - padding) / width) * (realRange.xMax - realRange.xMin);
            const y2 = x*x*x + realCurve.a*x + realCurve.b;
            if (y2 < 0) return; // click x where curve has no real point
            const yTop = Math.sqrt(y2);
            const yBot = -yTop;
            const topPy = cssHeight - padding - ( (yTop - realRange.yMin) * (height/(realRange.yMax - realRange.yMin)) );
            const botPy = cssHeight - padding - ( (yBot - realRange.yMin) * (height/(realRange.yMax - realRange.yMin)) );
            const pickY = (Math.abs(topPy - clickY) < Math.abs(botPy - clickY)) ? yTop : yBot;

            const px = document.getElementById('realMulPX');
            const py = document.getElementById('realMulPY');
            if (px) px.value = x;
            if (py) py.value = pickY;

            // Preview on the multiplication canvas
            visualizeRealScalarStep(0);
        }

        async function addPointsReal(){
            const a = parseFloat(document.getElementById('realParamA').value);
            const b = parseFloat(document.getElementById('realParamB').value);
            const p1x = parseFloat(document.getElementById('realP1X').value);
            const p1y = parseFloat(document.getElementById('realP1Y').value);
            const p2x = parseFloat(document.getElementById('realP2X').value);
            const p2y = parseFloat(document.getElementById('realP2Y').value);
            const resDiv = document.getElementById('realAdditionResult');
            if ([p1x,p1y,p2x,p2y].some(v => Number.isNaN(v))) {
                resDiv.innerHTML = '<div class="error">Please provide P and Q</div>';
                return;
            }
            // Validate range bounds
            const within = (x,y) => x>=realRange.xMin && x<=realRange.xMax && y>=realRange.yMin && y<=realRange.yMax;
            if (!within(p1x,p1y) || !within(p2x,p2y)){
                resDiv.innerHTML = `<div class="error">Points must lie within [${realRange.xMin}, ${realRange.xMax}] √ó [${realRange.yMin}, ${realRange.yMax}]</div>`;
                return;
            }
            resDiv.innerHTML = '<p style="color:#888;">Calculating...</p>';
            try{
                const r = await fetch('/api/add_points_real',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({a, b, p1:{x:p1x,y:p1y,display:''}, p2:{x:p2x,y:p2y,display:''}})});
                const data = await r.json();
                if (!r.ok || !data.success){ resDiv.innerHTML = `<div class="error">${data.error||'Error'}</div>`; return; }
                realCurve = {a,b};
                realP = {x:p1x, y:p1y};
                realQ = {x:p2x, y:p2y};
                realR = data.result.x === null ? null : {x:data.result.x, y:data.result.y};
                resDiv.innerHTML = `<div class="operation-result"><strong>P</strong> = (${formatNum(p1x)}, ${formatNum(p1y)})<br><strong>Q</strong> = (${formatNum(p2x)}, ${formatNum(p2y)})<br><strong>P + Q</strong> = ${realR?`(${formatNum(realR.x)}, ${formatNum(realR.y)})`:'O'}</div>`;
                drawRealAdditionScene();
                // reset auto-pick to P after calculation
                realPickPhase = 'P'; const _modeEl = document.getElementById('realSelectMode'); if (_modeEl) _modeEl.value = 'P';
                startRealAdditionAnimation();
            }catch(e){ resDiv.innerHTML = '<div class="error">Connection error</div>'; }
        }

        function drawRealAdditionScene(){
            const canvas = document.getElementById('realAdditionCanvas');
            if (!canvas) return;
            const showLabels = document.getElementById('realAdditionShowLabels')?.checked;
            const { ctx, cssWidth, cssHeight } = setupCanvas(canvas);
            ctx.clearRect(0,0,cssWidth,cssHeight);
            drawRealAxesGrid(ctx, canvas);
            drawRealCurve(ctx, canvas, realCurve.a, realCurve.b);

            // Draw points and line
            if (realP){ drawRealPoint(ctx, canvas, realP, '#667eea', 'P', showLabels); }
            if (realQ){ drawRealPoint(ctx, canvas, realQ, '#764ba2', 'Q', showLabels); }
            if (realP && realQ && !(_realAddAnim && _realAddAnim.active)){
                let m;
                if (Math.abs(realP.x - realQ.x) < 1e-12 && Math.abs(realP.y - realQ.y) < 1e-12) {
                    if (Math.abs(realP.y) < 1e-12) { m = null; } else { m = (3*realP.x*realP.x + realCurve.a) / (2*realP.y); }
                } else {
                    if (Math.abs(realQ.x - realP.x) < 1e-12) { m = null; } else { m = (realQ.y - realP.y) / (realQ.x - realP.x); }
                }
                if (Number.isFinite(m)){
                    // draw chord/tangent line across the viewport
                    const x1 = realRange.xMin, x2 = realRange.xMax;
                    const yAt = (x) => m*(x - realP.x) + realP.y;
                    const pA = mapRealToCanvas(canvas, x1, yAt(x1));
                    const pB = mapRealToCanvas(canvas, x2, yAt(x2));
                    ctx.strokeStyle = '#999'; ctx.lineWidth = 1.5;
                    ctx.beginPath(); ctx.moveTo(pA.px, pA.py); ctx.lineTo(pB.px, pB.py); ctx.stroke();
                }
            }
            if (realR){
                // -R (reflection across x-axis)
                const minusR = {x: realR.x, y: -realR.y};
                drawRealPoint(ctx, canvas, minusR, '#aaaaaa', '-R', showLabels);
                drawRealPoint(ctx, canvas, realR, '#e6e6e6', 'R', showLabels);
                // reflection helper line
                const up = mapRealToCanvas(canvas, realR.x, realR.y);
                const dn = mapRealToCanvas(canvas, minusR.x, minusR.y);
                ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.setLineDash([4,4]);
                ctx.beginPath(); ctx.moveTo(up.px, up.py); ctx.lineTo(dn.px, dn.py); ctx.stroke(); ctx.setLineDash([]);
            }
        }

        // Animated addition for real curves
        let _realAddAnim = { active:false, raf:null };
        function startRealAdditionAnimation(){
            if (!realP || !realQ) return;
            if (_realAddAnim.raf) cancelAnimationFrame(_realAddAnim.raf);
            _realAddAnim = { active:true, raf:null };
            const start = performance.now();
            const phaseDur = { line: 800, hold: 250, reflect: 700, reveal: 250 };
            const x1 = realRange.xMin, x2 = realRange.xMax;
            let m = null, vertical=false;
            if (Math.abs(realP.x - realQ.x) < 1e-12 && Math.abs(realP.y - realQ.y) < 1e-12) {
                if (Math.abs(realP.y) < 1e-12) vertical = true; else m = (3*realP.x*realP.x + realCurve.a) / (2*realP.y);
            } else { if (Math.abs(realQ.x - realP.x) < 1e-12) vertical = true; else m = (realQ.y - realP.y) / (realQ.x - realP.x); }
            const yAt = (x)=> m*(x - realP.x) + realP.y;
            const minusR = realR? {x: realR.x, y: -realR.y} : null;

            const tick = (now)=>{
                const elapsed = now - start;
                const t1 = Math.min(1, elapsed / phaseDur.line);
                const t2 = Math.min(1, Math.max(0, (elapsed - phaseDur.line - phaseDur.hold) / phaseDur.reflect));
                const t3 = Math.min(1, Math.max(0, (elapsed - phaseDur.line - phaseDur.hold - phaseDur.reflect) / phaseDur.reveal));

                const canvas = document.getElementById('realAdditionCanvas');
                const { ctx, cssWidth, cssHeight } = setupCanvas(canvas);
                ctx.clearRect(0,0,cssWidth,cssHeight);
                drawRealAxesGrid(ctx, canvas);
                drawRealCurve(ctx, canvas, realCurve.a, realCurve.b);
                drawRealPoint(ctx, canvas, realP, '#667eea', 'P', true);
                drawRealPoint(ctx, canvas, realQ, '#764ba2', 'Q', true);

                // animate chord/tangent line
                if (vertical){
                    const x = realP.x;
                    const yStart = realRange.yMin; const yEnd = realRange.yMax;
                    const a = mapRealToCanvas(canvas, x, yStart);
                    const b = mapRealToCanvas(canvas, x, yStart + t1*(yEnd - yStart));
                    ctx.strokeStyle = '#999'; ctx.lineWidth = 1.5;
                    ctx.beginPath(); ctx.moveTo(a.px, a.py); ctx.lineTo(b.px, b.py); ctx.stroke();
                } else {
                    const xa = x1; const xb = x1 + t1*(x2 - x1);
                    const pA = mapRealToCanvas(canvas, xa, yAt(xa));
                    const pB = mapRealToCanvas(canvas, xb, yAt(xb));
                    ctx.strokeStyle = '#999'; ctx.lineWidth = 1.5;
                    ctx.beginPath(); ctx.moveTo(pA.px, pA.py); ctx.lineTo(pB.px, pB.py); ctx.stroke();
                }

                if (minusR && elapsed > phaseDur.line){
                    const alpha = 0.2 + 0.8 * Math.min(1, (elapsed - phaseDur.line)/200);
                    ctx.globalAlpha = alpha; drawRealPoint(ctx, canvas, minusR, '#aaaaaa', '-R', true); ctx.globalAlpha = 1;
                }
                if (realR && elapsed > phaseDur.line + phaseDur.hold){
                    const up = mapRealToCanvas(canvas, realR.x, realR.y);
                    const dn = mapRealToCanvas(canvas, realR.x, -realR.y);
                    const midY = up.py + t2*(dn.py - up.py);
                    ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.setLineDash([4,4]);
                    ctx.beginPath(); ctx.moveTo(up.px, up.py); ctx.lineTo(up.px, midY); ctx.stroke(); ctx.setLineDash([]);
                }
                if (realR && elapsed > phaseDur.line + phaseDur.hold + phaseDur.reflect){
                    ctx.globalAlpha = t3; drawRealPoint(ctx, canvas, realR, '#e6e6e6', 'R', true); ctx.globalAlpha = 1;
                }

                if (elapsed < (phaseDur.line + phaseDur.hold + phaseDur.reflect + phaseDur.reveal)){
                    _realAddAnim.raf = requestAnimationFrame(tick);
                } else {
                    _realAddAnim.active = false; _realAddAnim.raf = null; drawRealAdditionScene();
                }
            };
            _realAddAnim.raf = requestAnimationFrame(tick);
        }

        function drawRealPoint(ctx, canvas, pt, color, label, showLabel){
            const {px, py} = mapRealToCanvas(canvas, pt.x, pt.y);
            ctx.fillStyle = color; ctx.beginPath(); ctx.arc(px, py, 5, 0, 2*Math.PI); ctx.fill();
            if (showLabel){
                ctx.font = '12px monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillText(`${label}(${formatNum(pt.x)}, ${formatNum(pt.y)})`, px, py - 12 + 1);
                ctx.fillStyle = color; ctx.fillText(`${label}(${formatNum(pt.x)}, ${formatNum(pt.y)})`, px, py - 12);
            }
        }

        async function scalarMultiplyReal(){
            const a = parseFloat(document.getElementById('realParamA').value);
            const b = parseFloat(document.getElementById('realParamB').value);
            const k = parseInt(document.getElementById('realK').value);
            const px = parseFloat(document.getElementById('realMulPX').value);
            const py = parseFloat(document.getElementById('realMulPY').value);
            const resDiv = document.getElementById('realScalarResult');
            if ([px,py].some(Number.isNaN) || Number.isNaN(k)){
                resDiv.innerHTML = '<div class="error">Enter P and k</div>';
                return;
            }
            if (!(px>=realRange.xMin && px<=realRange.xMax && py>=realRange.yMin && py<=realRange.yMax)){
                resDiv.innerHTML = `<div class="error">Point P must lie within [${realRange.xMin}, ${realRange.xMax}] √ó [${realRange.yMin}, ${realRange.yMax}]</div>`;
                return;
            }
            resDiv.innerHTML = '<p style="color:#888;">Calculating...</p>';
            try{
                const r = await fetch('/api/scalar_multiply_real',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({a,b,k, point:{x:px,y:py,display:''}})});
                const data = await r.json();
                if (!r.ok || !data.success){ resDiv.innerHTML = `<div class=\"error\">${data.error||'Error'}</div>`; return; }
                realCurve = {a,b};
                realScalarSteps = data.steps || [];
                realScalarPoints = data.points || [];
                realCurrentStep = 0;
                startRealMultiplicationAnimation();
                const disp = data.result.display;
                resDiv.innerHTML = `<div class=\"operation-result\"><strong>P</strong> = (${formatNum(px)}, ${formatNum(py)})<br><strong>k</strong> = ${k}<br><strong>${k} √ó P</strong> = ${disp}</div>`;
            }catch(e){ resDiv.innerHTML = '<div class="error">Connection error</div>'; }
        }

        function visualizeRealScalarStep(step){
            const canvas = document.getElementById('realMultiplicationCanvas');
            if (!canvas) return;
            const showLabels = document.getElementById('realMultiplicationShowLabels')?.checked;
            const { ctx, cssWidth, cssHeight } = setupCanvas(canvas);
            ctx.clearRect(0,0,cssWidth,cssHeight);
            drawRealAxesGrid(ctx, canvas);
            drawRealCurve(ctx, canvas, realCurve.a, realCurve.b);
            // Draw all computed multiples; always label as 1P, 2P, ...
            if (realScalarPoints && realScalarPoints.length){
                for (let i=0;i<realScalarPoints.length; i++){
                    const pt = realScalarPoints[i];
                    if (pt.x !== null){
                        // draw point
                        drawRealPoint(ctx, canvas, pt, '#e6e6e6', '', false);
                        const pxy = mapRealToCanvas(canvas, pt.x, pt.y);
                        const lbl = `${i+1}P`;
                        // always draw 1P,2P label
                        ctx.font = '12px monospace';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.fillStyle = 'rgba(0,0,0,0.6)';
                        ctx.fillText(lbl, pxy.px, pxy.py - 12 + 1);
                        ctx.fillStyle = '#bbb';
                        ctx.fillText(lbl, pxy.px, pxy.py - 12);
                        // if toggled, also show coordinates under the label
                        if (showLabels){
                            const coord = `(${formatNum(pt.x)}, ${formatNum(pt.y)})`;
                            ctx.fillStyle = 'rgba(0,0,0,0.6)';
                            ctx.fillText(coord, pxy.px, pxy.py - 26 + 1);
                            ctx.fillStyle = '#bbb';
                            ctx.fillText(coord, pxy.px, pxy.py - 26);
                        }
                    }
                }
            }
            // If no steps yet, draw the currently selected P from inputs (for preview)
            if (!realScalarPoints || realScalarPoints.length === 0){
                const px = parseFloat(document.getElementById('realMulPX').value);
                const py = parseFloat(document.getElementById('realMulPY').value);
                if (!Number.isNaN(px) && !Number.isNaN(py)){
                    // Only show if within current axis range
                    if (px>=realRange.xMin && px<=realRange.xMax && py>=realRange.yMin && py<=realRange.yMax){
                        drawRealPoint(ctx, canvas, {x:px, y:py}, '#667eea', 'P', showLabels);
                    }
                }
            }
            // no step label
        }
        function renderRealScalarAll(){ visualizeRealScalarStep(0); }

        // Animate real multiplication by progressively revealing 1P..kP
        let _realMulAnim = { active:false, raf:null };
        function renderRealScalarPartial(count){
            const canvas = document.getElementById('realMultiplicationCanvas');
            if (!canvas) return;
            const showLabels = document.getElementById('realMultiplicationShowLabels')?.checked;
            const { ctx, cssWidth, cssHeight } = setupCanvas(canvas);
            ctx.clearRect(0,0,cssWidth,cssHeight);
            drawRealAxesGrid(ctx, canvas);
            drawRealCurve(ctx, canvas, realCurve.a, realCurve.b);
            const n = Math.min(count, realScalarPoints.length);
            for (let i=0;i<n;i++){
                const pt = realScalarPoints[i];
                if (!pt || pt.x === null) continue;
                drawRealPoint(ctx, canvas, pt, '#e6e6e6', '', false);
                const pxy = mapRealToCanvas(canvas, pt.x, pt.y);
                const lbl = `${i+1}P`;
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillText(lbl, pxy.px, pxy.py - 12 + 1);
                ctx.fillStyle = '#bbb';
                ctx.fillText(lbl, pxy.px, pxy.py - 12);
                if (showLabels){
                    const coord = `(${formatNum(pt.x)}, ${formatNum(pt.y)})`;
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fillText(coord, pxy.px, pxy.py - 26 + 1);
                    ctx.fillStyle = '#bbb';
                    ctx.fillText(coord, pxy.px, pxy.py - 26);
                }
            }
        }
        function startRealMultiplicationAnimation(){
            if (!realScalarPoints || !realScalarPoints.length){ renderRealScalarAll(); return; }
            if (_realMulAnim.raf) cancelAnimationFrame(_realMulAnim.raf);
            _realMulAnim.active = true;
            const start = performance.now();
            const per = 320;
            const step = (now)=>{
                const elapsed = now - start;
                const shown = Math.min(realScalarPoints.length, Math.floor(elapsed / per) + 1);
                renderRealScalarPartial(shown);
                if (shown < realScalarPoints.length){ _realMulAnim.raf = requestAnimationFrame(step); }
                else { _realMulAnim.active=false; _realMulAnim.raf=null; renderRealScalarAll(); }
            };
            _realMulAnim.raf = requestAnimationFrame(step);
        }

        function realPrevScalarStep(){ if (realCurrentStep>0){ realCurrentStep--; document.getElementById('realStepSlider').value = realCurrentStep; visualizeRealScalarStep(realCurrentStep); updateRealStepLabel(); } }
        function realNextScalarStep(){ if (realScalarSteps && realCurrentStep < realScalarSteps.length-1){ realCurrentStep++; document.getElementById('realStepSlider').value = realCurrentStep; visualizeRealScalarStep(realCurrentStep); updateRealStepLabel(); } }
        function onRealScalarSlider(v){ realCurrentStep = parseInt(v); visualizeRealScalarStep(realCurrentStep); updateRealStepLabel(); }
        function toggleRealScalarAnimation(){
            const btn = document.getElementById('realPlayPauseBtn');
            if (realAnimInterval){ clearInterval(realAnimInterval); realAnimInterval=null; btn.textContent='Play'; }
            else {
                btn.textContent='Pause';
                realAnimInterval = setInterval(()=>{
                    if (realScalarSteps && realCurrentStep < realScalarSteps.length - 1) { realNextScalarStep(); }
                    else { clearInterval(realAnimInterval); realAnimInterval=null; btn.textContent='Play'; realCurrentStep=0; }
                }, 1000);
            }
        }
        function updateRealStepLabel(){ document.getElementById('realStepLabel').textContent = `${realCurrentStep + 1}/${realScalarSteps.length}`; }
    </script>
    <script>
        // -------- Operation History (frontend) --------
        async function loadHistory(curveType){
            const endpoint = (curveType === 'fp') ? '/api/history/fp' : '/api/history/real';
            try{
                const res = await fetch(endpoint);
                const data = await res.json();
                displayHistory(curveType, Array.isArray(data)? data: (data.history || []));
            }catch(e){
                const el = document.getElementById(`${curveType}-history-list`);
                if (el) el.innerHTML = '<p style="color:#666; text-align:center;">Failed to load history</p>';
            }
        }

        function getOperationIcon(type){
            if (!type) return 'üìù';
            if (type.includes('add')) return '‚ûï';
            if (type.includes('multiply')) return '‚úñÔ∏è';
            if (type.includes('init')) return 'üìê';
            return 'üìù';
        }

        function formatTimestamp(ts){ return ts || ''; }

        function formatOperationDescription(item){
            try{
                const p = item.parameters || {};
                const r = item.result || {};
                if (item.operation_type === 'add_fp'){
                    return `Added ${p.P?.display||''} + ${p.Q?.display||''} = ${r.R?.display||''}`;
                }
                if (item.operation_type === 'multiply_fp'){
                    return `Multiplied ${p.k} √ó ${p.P?.display||''} = ${r.R?.display||''}`;
                }
                if (item.operation_type === 'init_fp'){
                    return `Init a=${p.a}, b=${p.b}, p=${p.p}`;
                }
                if (item.operation_type === 'add_real'){
                    return `Added (${p.P?.x?.toFixed?.(2)||p.P?.x}, ${p.P?.y?.toFixed?.(2)||p.P?.y}) + (${p.Q?.x?.toFixed?.(2)||p.Q?.x}, ${p.Q?.y?.toFixed?.(2)||p.Q?.y})`;
                }
                if (item.operation_type === 'multiply_real'){
                    return `Multiplied ${p.k} √ó (${p.P?.x?.toFixed?.(2)||p.P?.x}, ${p.P?.y?.toFixed?.(2)||p.P?.y})`;
                }
                if (item.operation_type === 'init_real'){
                    return `Init a=${p.a}, b=${p.b}`;
                }
            }catch(_){ }
            return '';
        }

        function displayHistory(curveType, history){
            const listElement = document.getElementById(`${curveType}-history-list`);
            if (!listElement) return;
            if (!history || history.length === 0){
                listElement.innerHTML = '<p style="color:#666; text-align:center;">No operations yet</p>';
                return;
            }
            listElement.innerHTML = history.map(item => {
                const icon = getOperationIcon(item.operation_type);
                const desc = formatOperationDescription(item);
                return `
                <div class="history-item" onclick="replayOperation(${item.id})">
                    <span class="operation-icon">${icon}</span>
                    <div class="operation-details">
                        <div class="operation-type">${item.operation_type}</div>
                        <div class="operation-params">${desc}</div>
                        <div class="timestamp">${formatTimestamp(item.timestamp)}</div>
                    </div>
                </div>`;
            }).join('');
        }

        async function replayOperation(historyId){
            try{
                const res = await fetch(`/api/history/replay/${historyId}`, {method:'POST'});
                const data = await res.json();
                if (!res.ok || !data.success){ alert('Could not replay'); return; }
                const ct = (data.curve_type || '').toLowerCase();
                const op = data.operation_type || '';
                // Ensure parent tab is active
                if (ct === 'fp') { switchTab('fpTab'); } else { switchTab('realTab'); }
                // Always reinitialize curve first
                await restoreCurveInit(ct, data.parameters);
                // Navigate to appropriate subtab and perform op
                if (op.includes('init')){
                    switchToOperationsSubtab(ct); // init pane
                } else if (op.includes('add')){
                    if (ct === 'fp') { switchSubtab('fp','fpAddPane'); }
                    else { switchSubtab('real','realAddPane'); }
                    await restorePointAddition(ct, data.parameters, data.result);
                } else if (op.includes('multiply')){
                    if (ct === 'fp') { switchSubtab('fp','fpMulPane'); }
                    else { switchSubtab('real','realMulPane'); }
                    await restoreScalarMultiplication(ct, data.parameters, data.result);
                } else {
                    switchToOperationsSubtab(ct);
                }
            }catch(_){ alert('Replay failed'); }
        }

        function switchToOperationsSubtab(ct){
            if (ct === 'fp') { switchSubtab('fp','fpInitPane'); }
            else { switchSubtab('real','realInitPane'); }
        }

        function refreshHistory(ct){ loadHistory(ct); }
        async function clearHistory(ct){ if (!confirm('Clear all history?')) return; await fetch(`/api/history/clear/${ct}`, {method:'DELETE'}); loadHistory(ct); }

        // Restore helpers
        async function restoreCurveInit(ct, params){
            if (ct === 'fp'){
                if (params){
                    document.getElementById('paramA').value = params.a;
                    document.getElementById('paramB').value = params.b;
                    if (params.p !== undefined) document.getElementById('paramP').value = params.p;
                }
                await findAllPoints();
            } else {
                if (params){
                    document.getElementById('realParamA').value = params.a;
                    document.getElementById('realParamB').value = params.b;
                }
                await initRealCurve();
            }
        }

        async function restorePointAddition(ct, params, result){
            if (ct === 'fp'){
                // Try to select P and Q by display text
                const pSel = document.getElementById('point1Select');
                const qSel = document.getElementById('point2Select');
                const setByDisplay = (sel, disp)=>{
                    if (!sel) return;
                    for (let i=0;i<sel.options.length;i++){ if (sel.options[i].textContent === (disp||'')) { sel.selectedIndex = i; break; } }
                };
                setByDisplay(pSel, params?.P?.display);
                setByDisplay(qSel, params?.Q?.display);
                await addPoints();
            } else {
                if (params?.P){ document.getElementById('realP1X').value = params.P.x; document.getElementById('realP1Y').value = params.P.y; }
                if (params?.Q){ document.getElementById('realP2X').value = params.Q.x; document.getElementById('realP2Y').value = params.Q.y; }
                await addPointsReal();
            }
        }

        async function restoreScalarMultiplication(ct, params, result){
            if (ct === 'fp'){
                const pSel = document.getElementById('scalarPointSelect');
                const setByDisplay = (sel, disp)=>{
                    if (!sel) return;
                    for (let i=0;i<sel.options.length;i++){ if (sel.options[i].textContent === (disp||'')) { sel.selectedIndex = i; break; } }
                };
                setByDisplay(pSel, params?.P?.display);
                document.getElementById('scalarValue').value = params?.k ?? 1;
                await scalarMultiply();
            } else {
                if (params?.P){ document.getElementById('realMulPX').value = params.P.x; document.getElementById('realMulPY').value = params.P.y; }
                document.getElementById('realK').value = params?.k ?? 1;
                await scalarMultiplyReal();
            }
        }
    </script>
</body>
</html>
